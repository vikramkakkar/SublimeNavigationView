/*
 * Copyright 2015 Vikram Kakkar
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.appeaser.sublimenavigationviewlibrary;

import android.content.Context;
import android.content.res.Resources;
import android.os.Parcel;
import android.os.Parcelable;
import android.support.annotation.Nullable;
import android.util.Log;
import android.util.SparseArray;

import java.util.ArrayList;
import java.util.List;

/**
 * Menu implementation.
 *
 * Created by Vikram.
 */
public class SublimeMenu implements Parcelable {
    private static final String TAG = SublimeMenu.class.getSimpleName();

    public static final int NO_GROUP_ID = -1;
    public static final int NO_ITEM_ID = -1;

    protected static final SublimeBaseMenuItem HEADER_STUB = new SublimeBaseMenuItem(null,
            NO_GROUP_ID, NO_ITEM_ID, "", "", SublimeBaseMenuItem.ItemType.HEADER, false, false) {
        @Override
        public boolean invoke() {
            return false;
        }
    };

    private int mMenuResourceID = -1;

    private Context mContext;

    /**
     * Callback that will receive the various menu-related events generated by this class. Use
     * getCallback to get a reference to the callback.
     */
    private Callback mCallback;

    /**
     * Contains all of the items for this menu
     */
    private ArrayList<SublimeBaseMenuItem> mItems = new ArrayList<>();

    /**
     * Contains all of the groups for this menu
     */
    private ArrayList<SublimeGroup> mGroups = new ArrayList<>();

    /**
     * Contains only the items that are currently visible.  This will be created/refreshed from
     * {@link #getVisibleItems()}
     */
    private ArrayList<SublimeBaseMenuItem> mVisibleItems = new ArrayList<>();

    // We only require _one_ presenter
    private SublimeMenuPresenter mPresenter;

    private boolean mBlockUpdates;

    private ArrayList<SublimeBaseMenuItem> mAdapterData = new ArrayList<>();

    /**
     * Called by menu to notify of close and selection changes.
     */
    public interface Callback {

        /**
         * Called when a menu item is selected.
         *
         * @param menu  The menu that is the parent of the item
         * @param item  The menu item that is selected
         * @param event EventType associated with this selection
         * @return whether the menu item selection was handled
         */
        boolean onMenuItemSelected(SublimeMenu menu, SublimeBaseMenuItem item,
                                   OnNavigationMenuEventListener.Event event);
    }

    public SublimeMenu(int menuResourceID) {
        mMenuResourceID = menuResourceID;
    }

    public int getMenuResourceID() {
        return mMenuResourceID;
    }

    /**
     * Set a presenter to this menu.
     *
     * @param presenter The presenter to set
     */
    public void setMenuPresenter(Context context, @Nullable SublimeMenuPresenter presenter) {
        mContext = context;
        mPresenter = presenter;

        if (presenter != null) {
            if (Config.DEBUG) {
                Log.d(TAG, "Presenter set on menu");
            }
            presenter.initForMenu(mContext, this);
            presenter.invalidateEntireMenu();
        }
    }

    public void setCallback(Callback cb) {
        mCallback = cb;
    }

    public SublimeGroup addGroup(boolean isCollapsible,
                                 boolean collapsed, boolean enabled,
                                 boolean visible,
                                 SublimeGroup.CheckableBehavior checkableBehavior) {
        return addGroup(generateUniqueGroupID(), isCollapsible, collapsed,
                enabled, visible, checkableBehavior);
    }

    protected SublimeGroup addGroup(int groupId, boolean isCollapsible,
                                    boolean collapsed, boolean enabled,
                                    boolean visible,
                                    SublimeGroup.CheckableBehavior checkableBehavior) {
        SublimeGroup group = new SublimeGroup(this,
                groupId,
                isCollapsible, collapsed, enabled,
                visible, checkableBehavior);
        mGroups.add(group);
        return group;
    }

    private int generateUniqueGroupID() {
        int groupId = 1;

        if (mGroups.size() > 0) {
            while (getGroup(groupId) != null) {
                groupId++;
            }
        }

        return groupId;
    }

    private int generateUniqueItemID() {
        int menuItemId = 1;

        if (mItems.size() > 0) {
            while (getMenuItem(menuItemId) != null) {
                menuItemId++;
            }
        }

        return menuItemId;
    }

    /**
     * Adds an item to the menu.  The other add methods funnel to this.
     */
    private SublimeBaseMenuItem addInternal(int group, int id, CharSequence title,
                                            CharSequence hint,
                                            SublimeBaseMenuItem.ItemType itemType,
                                            boolean valueProvidedAsync,
                                            CharSequence badgeText,
                                            boolean showsIconSpace, boolean addedByUser) {
        SublimeBaseMenuItem item;
        boolean isGroupHeader = false;

        switch (itemType) {
            case SEPARATOR:
                item = new SublimeSeparatorMenuItem(this, group, id);
                break;
            case BADGE:
                item = new SublimeTextWithBadgeMenuItem(this, group, id, title,
                        hint, valueProvidedAsync, badgeText, showsIconSpace);
                break;
            case SWITCH:
                item = new SublimeSwitchMenuItem(this, group, id, title,
                        hint, valueProvidedAsync, showsIconSpace);
                break;
            case CHECKBOX:
                item = new SublimeCheckboxMenuItem(this, group, id, title,
                        hint, valueProvidedAsync,
                        showsIconSpace);
                break;
            case GROUP_HEADER:
                isGroupHeader = true;
                item = new SublimeGroupHeaderMenuItem(this, group, id, title,
                        hint, valueProvidedAsync, showsIconSpace);
                break;
            default:
                // TEXT
                item = new SublimeTextMenuItem(this, group, id, title,
                        hint, valueProvidedAsync, showsIconSpace);
                break;
        }

        // if itemType is 'GroupHeader', 'group' != NO_GROUP_ID
        // since we check for this in 'addGroupHeaderItem(...)'
        checkExistenceOfGroup(group);

        if (isGroupHeader) {
            checkIfGroupHeaderAlreadyExistsForGroup(group);
            int index = findGroupIndex(group);

            if (index >= 0) {
                mItems.add(index, item);
            } else {
                mItems.add(item);
            }
        } else if (addedByUser) {
            if (group != NO_GROUP_ID) {
                int lastGroupIndex = findLastGroupIndex(group);

                mItems.add(lastGroupIndex == mItems.size() ?
                        lastGroupIndex : lastGroupIndex + 1, item);
            } else {
                mItems.add(item);
            }
        } else {
            mItems.add(item);
        }

        onItemsChanged();

        return item;
    }

    public enum Positioned {BEFORE, AFTER}

    /**
     * Adds an item to the menu and positions it using the given `pivot`.
     *
     * @param pivotID    Item ID that will be used for positioning the added item
     * @param positioned before or after
     * @param newItem    added item
     * @return item that was just added
     */
    private SublimeBaseMenuItem addInternal(int pivotID, Positioned positioned,
                                            SublimeBaseMenuItem newItem) {
        int newItemGroupId = newItem.getGroupId();

        // if itemType is 'GroupHeader', 'group' != NO_GROUP_ID
        // since we check for this in 'addGroupHeaderItem(...)'
        checkExistenceOfGroup(newItemGroupId);

        int pivotIndex = findItemIndex(pivotID);
        SublimeBaseMenuItem pivot = mItems.get(pivotIndex);

        // GROUP_HEADER is a special item. In addition to the positional
        // requirements given above, it should be placed at the beginning
        // of the Group.
        if (newItem.getItemType() == SublimeBaseMenuItem.ItemType.GROUP_HEADER) {
            checkIfGroupHeaderAlreadyExistsForGroup(newItemGroupId);
            int index = findGroupIndex(newItemGroupId);

            if (index >= 0) { // we found a valid index for the group
                mItems.add(index, newItem);
            } else { // group exists, but does not contain any items at the moment
                // try to use the `pivot` to place the first group item
                if (positioned == Positioned.BEFORE) {
                    if (pivot.getGroupId() == NO_GROUP_ID
                            || pivot.getItemType()
                            == SublimeBaseMenuItem.ItemType.GROUP_HEADER) {
                        // `pivot` is not part of a Group
                        // - or -
                        // `pivot` is a GROUP_HEADER
                        mItems.add(pivotIndex, newItem);
                    } else {
                        // we could not position the item as per the
                        // requirements - add the item at the very end
                        mItems.add(newItem);
                    }
                } else if (positioned == Positioned.AFTER) {
                    if (pivot.getGroupId() == NO_GROUP_ID
                            || pivotIndex
                            == findLastGroupIndex(newItemGroupId)) {
                        // `pivot` is not part of a Group
                        // - or -
                        // `pivot` is the very last item in a Group
                        mItems.add(pivotIndex + 1, newItem);
                    } else {
                        // we could not position the item as per the
                        // requirements - add the item at the very end
                        mItems.add(newItem);
                    }
                }
            }
        } else { // item is not a GROUP_HEADER
            if (newItemGroupId != NO_GROUP_ID) { // item is part of a Group
                int lastGroupIndex = findLastGroupIndex(newItemGroupId);

                if (lastGroupIndex == mItems.size()) { // no Group items found
                    // try to use the `pivot` to position the new item
                    if (positioned == Positioned.BEFORE) {
                        if (pivot.getGroupId() == NO_GROUP_ID
                                || pivotIndex == findGroupIndex(pivot.getGroupId())) {
                            // `pivot` is not part of a Group
                            // - or -
                            // `pivot` is the very first item in a Group
                            mItems.add(pivotIndex, newItem);
                        } else {
                            // we could not position the item as per the
                            // requirements - add the item at the very end
                            //mItems.add(lastGroupIndex + 1, item);
                            mItems.add(newItem);
                        }
                    } else if (positioned == Positioned.AFTER) {
                        if (pivot.getGroupId() == NO_GROUP_ID
                                || pivotIndex == findLastGroupIndex(pivot.getGroupId())) {
                            // `pivot` is not part of a Group
                            // - or -
                            // `pivot` is the very last item in a Group
                            mItems.add(pivotIndex + 1, newItem);
                        } else {
                            // we could not position the item as per the
                            // requirements - add the item at the very end
                            //mItems.add(lastGroupIndex + 1, item);
                            mItems.add(newItem);
                        }
                    }
                } else {
                    if (newItemGroupId == pivot.getGroupId()) {
                        if (positioned == Positioned.BEFORE) {
                            if (pivot.getItemType()
                                    != SublimeBaseMenuItem.ItemType.GROUP_HEADER) {
                                // `pivot` is not GroupHeader - add before
                                mItems.add(pivotIndex, newItem);
                            } else {
                                // cannot add an item before the GroupHeader.
                                // add item at the end of the Group
                                mItems.add(lastGroupIndex + 1, newItem);
                            }
                        } else if (positioned == Positioned.AFTER) {
                            // all positions after the `pivot` are valid
                            mItems.add(pivotIndex + 1, newItem);
                        }
                    } else {
                        // `newItem` & `pivot` belong to different Groups.
                        // The only valid position for `newItem` in this case
                        // is at the end of `newItem's` Group.
                        mItems.add(lastGroupIndex + 1, newItem);
                    }
                }
            } else {
                // `newItem` is independent - no Group membership
                if (positioned == Positioned.BEFORE) {
                    if (pivot.getGroupId() == NO_GROUP_ID
                            || findGroupIndex(pivot.getGroupId()) == pivotIndex) {
                        // `pivot` is not part of a Group
                        // - or -
                        // `pivot` is the very first item in a Group
                        mItems.add(pivotIndex, newItem);
                    } else {
                        // we could not position the item as per the
                        // requirements - add the item at the very end
                        mItems.add(newItem);
                    }
                } else if (positioned == Positioned.AFTER) {
                    if (pivot.getGroupId() == NO_GROUP_ID
                            || pivotIndex == findLastGroupIndex(pivot.getGroupId())) {
                        // `pivot` is not part of a Group
                        // - or -
                        // `pivot` is the very last item in a Group
                        mItems.add(pivotIndex + 1, newItem);
                    } else {
                        // we could not position the item as per the
                        // requirements - add the item at the very end
                        mItems.add(newItem);
                    }
                }
            }
        }

        onItemsChanged();

        return newItem;
    }

    /**
     * Creates an item.  The other 'create' methods funnel to this.
     */
    private SublimeBaseMenuItem createInternal(int group, int id, CharSequence title,
                                               CharSequence hint,
                                               SublimeBaseMenuItem.ItemType itemType,
                                               boolean valueProvidedAsync,
                                               CharSequence badgeText,
                                               boolean showsIconSpace) {
        SublimeBaseMenuItem item;

        switch (itemType) {
            case SEPARATOR:
                item = new SublimeSeparatorMenuItem(this, group, id);
                break;
            case BADGE:
                item = new SublimeTextWithBadgeMenuItem(this, group, id, title,
                        hint, valueProvidedAsync, badgeText, showsIconSpace);
                break;
            case SWITCH:
                item = new SublimeSwitchMenuItem(this, group, id, title,
                        hint, valueProvidedAsync, showsIconSpace);
                break;
            case CHECKBOX:
                item = new SublimeCheckboxMenuItem(this, group, id, title,
                        hint, valueProvidedAsync,
                        showsIconSpace);
                break;
            case GROUP_HEADER:
                item = new SublimeGroupHeaderMenuItem(this, group, id, title,
                        hint, valueProvidedAsync, showsIconSpace);
                break;
            default:
                // TEXT
                item = new SublimeTextMenuItem(this, group, id, title,
                        hint, valueProvidedAsync, showsIconSpace);
                break;
        }

        return item;
    }

    /**
     * This check is performed before adding an item to this menu
     * that has positional instructions: addAfter(...), addBefore(...) etc..
     * Throws {@link RuntimeException} if the item
     * used for positioning does not exist.
     *
     * @param itemId ID of the item to check for
     */
    private void checkExistenceOfItem(int itemId) {
        if (itemId == NO_ITEM_ID || getMenuItem(itemId) == null) {
            throw new RuntimeException("'itemId' passed was invalid: '" + itemId + "'.");
        }
    }

    /**
     * This check is performed before adding an item to this menu.
     * If the item indicates its membership to a {@link SublimeGroup}
     * (by supplying a 'groupID'), this check confirms that such a
     * group does exist. Throws {@link RuntimeException} if a group
     * with ID == 'groupId' is not found.
     *
     * @param groupId ID of the group to check for
     */
    private void checkExistenceOfGroup(int groupId) {
        if (groupId != NO_GROUP_ID && getGroup(groupId) == null) {
            throw new RuntimeException("'groupId' passed was invalid: '" + groupId + "'. Items can only " +
                    "be added to existing Group(s)");
        }
    }

    /**
     * This check is performed before adding an item of type
     * {@link SublimeBaseMenuItem.ItemType#GROUP_HEADER}.
     * A {@link RuntimeException} is thrown if the {@link SublimeGroup}
     * already contains an item of this type. A {@link SublimeGroup}
     * can only have one header.
     *
     * @param groupId ID of the group on which to perform this check.
     */
    private void checkIfGroupHeaderAlreadyExistsForGroup(int groupId) {
        for (SublimeBaseMenuItem item : mItems) {
            if (item.getGroupId() == groupId
                    && item.getItemType() == SublimeBaseMenuItem.ItemType.GROUP_HEADER) {
                throw new RuntimeException("Attempt to add 'GroupHeader' to " +
                        "a 'Group' that already contains one.");
            }
        }
    }

    public SublimeBaseMenuItem createTextItem(int groupId,
                                              CharSequence title, CharSequence hint,
                                              boolean showsIconSpace) {
        return createInternal(groupId, generateUniqueItemID()/* itemId */,
                title, hint, SublimeBaseMenuItem.ItemType.TEXT,
                false /*valueProvidedAsync*/, null, showsIconSpace);
    }

    public SublimeBaseMenuItem addTextItem(int groupId,
                                           CharSequence title, CharSequence hint,
                                           boolean showsIconSpace) {
        return addInternal(groupId, generateUniqueItemID()/* itemId */, title, hint, SublimeBaseMenuItem.ItemType.TEXT,
                false /*valueProvidedAsync*/, null, showsIconSpace, true);
    }

    protected SublimeBaseMenuItem addTextItem(int groupId, int itemId,
                                              CharSequence title, CharSequence hint,
                                              boolean showsIconSpace) {
        return addInternal(groupId, itemId, title, hint, SublimeBaseMenuItem.ItemType.TEXT,
                false /*valueProvidedAsync*/, null, showsIconSpace, false);
    }

    public SublimeBaseMenuItem createTextWithBadgeItem(int groupId,
                                                       CharSequence title, CharSequence hint,
                                                       CharSequence badgeText,
                                                       boolean showsIconSpace) {
        return createInternal(groupId, generateUniqueItemID()/* itemId */, title,
                hint, SublimeBaseMenuItem.ItemType.BADGE,
                false /*valueProvidedAsync*/, badgeText, showsIconSpace);
    }

    public SublimeBaseMenuItem addTextWithBadgeItem(int groupId,
                                                    CharSequence title, CharSequence hint,
                                                    CharSequence badgeText,
                                                    boolean showsIconSpace) {
        return addInternal(groupId, generateUniqueItemID()/* itemId */, title,
                hint, SublimeBaseMenuItem.ItemType.BADGE,
                false /*valueProvidedAsync*/, badgeText, showsIconSpace, true);
    }

    protected SublimeBaseMenuItem addTextWithBadgeItem(int groupId, int itemId,
                                                       CharSequence title, CharSequence hint,
                                                       CharSequence badgeText,
                                                       boolean showsIconSpace) {
        return addInternal(groupId, itemId, title, hint, SublimeBaseMenuItem.ItemType.BADGE,
                false /*valueProvidedAsync*/, badgeText, showsIconSpace, false);
    }

    public SublimeBaseMenuItem createCheckboxItem(int groupId,
                                                  CharSequence title, CharSequence hint,
                                                  boolean showsIconSpace) {
        return createInternal(groupId, generateUniqueItemID()/* itemId */, title, hint, SublimeBaseMenuItem.ItemType.CHECKBOX,
                false /*valueProvidedAsync*/, null, showsIconSpace);
    }

    public SublimeBaseMenuItem addCheckboxItem(int groupId,
                                               CharSequence title, CharSequence hint,
                                               boolean showsIconSpace) {
        return addInternal(groupId, generateUniqueItemID()/* itemId */, title, hint, SublimeBaseMenuItem.ItemType.CHECKBOX,
                false /*valueProvidedAsync*/, null, showsIconSpace, true);
    }

    protected SublimeBaseMenuItem addCheckboxItem(int groupId, int itemId,
                                                  CharSequence title, CharSequence hint,
                                                  boolean showsIconSpace) {
        return addInternal(groupId, itemId, title,
                hint, SublimeBaseMenuItem.ItemType.CHECKBOX,
                false /*valueProvidedAsync*/, null, showsIconSpace, false);
    }

    public SublimeBaseMenuItem createSwitchItem(int groupId,
                                                CharSequence title, CharSequence hint,
                                                boolean showsIconSpace) {
        return createInternal(groupId, generateUniqueItemID()/* itemId */, title,
                hint, SublimeBaseMenuItem.ItemType.SWITCH,
                false /*valueProvidedAsync*/, null, showsIconSpace);
    }

    public SublimeBaseMenuItem addSwitchItem(int groupId,
                                             CharSequence title, CharSequence hint,
                                             boolean showsIconSpace) {
        return addInternal(groupId, generateUniqueItemID()/* itemId */, title,
                hint, SublimeBaseMenuItem.ItemType.SWITCH,
                false /*valueProvidedAsync*/, null, showsIconSpace, true);
    }

    protected SublimeBaseMenuItem addSwitchItem(int groupId, int itemId,
                                                CharSequence title, CharSequence hint,
                                                boolean showsIconSpace) {
        return addInternal(groupId, itemId, title,
                hint, SublimeBaseMenuItem.ItemType.SWITCH,
                false /*valueProvidedAsync*/, null, showsIconSpace, false);
    }

    public SublimeBaseMenuItem createGroupHeaderItem(int groupId,
                                                     CharSequence title, CharSequence hint,
                                                     boolean showsIconSpace) {
        if (groupId == NO_GROUP_ID) {
            throw new RuntimeException("Attempt to create 'GroupHeader' without " +
                    "providing a valid groupID");
        }

        return createInternal(groupId, generateUniqueItemID()/* itemId */, title, hint,
                SublimeBaseMenuItem.ItemType.GROUP_HEADER,
                false /*valueProvidedAsync*/, null, showsIconSpace);
    }

    public SublimeBaseMenuItem addGroupHeaderItem(int groupId,
                                                  CharSequence title, CharSequence hint,
                                                  boolean showsIconSpace) {
        if (groupId == NO_GROUP_ID) {
            throw new RuntimeException("Attempt to add 'GroupHeader' without " +
                    "providing a valid groupID");
        }

        return addInternal(groupId, generateUniqueItemID()/* itemId */, title, hint,
                SublimeBaseMenuItem.ItemType.GROUP_HEADER,
                false /*valueProvidedAsync*/, null, showsIconSpace, true);
    }

    protected SublimeBaseMenuItem addGroupHeaderItem(int groupId, int itemId,
                                                     CharSequence title, CharSequence hint,
                                                     boolean showsIconSpace) {
        return addInternal(groupId, itemId, title, hint,
                SublimeBaseMenuItem.ItemType.GROUP_HEADER,
                false /*valueProvidedAsync*/, null, showsIconSpace, false);
    }

    public SublimeBaseMenuItem createSeparatorItem(int groupId) {
        return createInternal(groupId, generateUniqueItemID()/* itemId */, null, null,
                SublimeBaseMenuItem.ItemType.SEPARATOR,
                false /*valueProvidedAsync*/, null, false);
    }

    public SublimeBaseMenuItem addSeparatorItem(int groupId) {
        return addInternal(groupId, generateUniqueItemID()/* itemId */, null, null,
                SublimeBaseMenuItem.ItemType.SEPARATOR,
                false /*valueProvidedAsync*/, null, false, true);
    }

    protected SublimeBaseMenuItem addSeparatorItem(int groupId, int itemId) {
        return addInternal(groupId, itemId, null, null,
                SublimeBaseMenuItem.ItemType.SEPARATOR,
                false /*valueProvidedAsync*/, null, false, false);
    }

    public void addBefore(int pivotId, SublimeBaseMenuItem item) {
        checkExistenceOfItem(pivotId);
        addInternal(pivotId, Positioned.BEFORE, item);
    }

    public void addAfter(int pivotId, SublimeBaseMenuItem item) {
        checkExistenceOfItem(pivotId);
        addInternal(pivotId, Positioned.AFTER, item);
    }

    public void removeItem(int id) {
        removeItemAtInt(findItemIndex(id), true);
    }

    public void removeGroup(int groupId) {
        final int i = findGroupIndex(groupId);

        if (i >= 0) {
            final int maxRemovable = mItems.size() - i;
            int numRemoved = 0;
            while ((numRemoved++ < maxRemovable) && (mItems.get(i).getGroupId() == groupId)) {
                // Don't force update for each one, this method will do it at the end
                removeItemAtInt(i, false);
            }

            // Remove Group
            int groups = mGroups.size();

            for (int j = 0; j < groups; j++) {
                SublimeGroup curGroup = mGroups.get(j);

                if (curGroup.getGroupId() == groupId) {
                    mGroups.remove(j);
                    break;
                }
            }

            // Notify menu views
            onItemsChanged();
        }
    }

    /**
     * Remove the item at the given index and optionally forces menu views to
     * update.
     *
     * @param index                     The index of the item to be removed. If this index is
     *                                  invalid an exception is thrown.
     * @param updateChildrenOnMenuViews Whether to force update on menu views.
     *                                  Please make sure you eventually call this after your batch of
     *                                  removals.
     */
    private void removeItemAtInt(int index, boolean updateChildrenOnMenuViews) {
        if ((index < 0) || (index >= mItems.size())) return;

        mItems.remove(index);

        if (updateChildrenOnMenuViews) {
            onItemsChanged();
        }
    }

    public void clear() {
        mItems.clear();
        mGroups.clear();
        onItemsChanged();
    }

    /**
     * Performs required changes to other group items
     * before the passed item's checked state is set to true.
     *
     * @param item Item on which setChecked(true) has been called
     */
    void setItemChecked(SublimeBaseMenuItem item) {
        SublimeGroup group = getGroup(item.getGroupId());

        if (group == null) return;

        if (group.getCheckableBehavior() == SublimeGroup.CheckableBehavior.SINGLE) {
            final int N = mItems.size();
            for (int i = 0; i < N; i++) {
                SublimeBaseMenuItem curItem = mItems.get(i);
                if (curItem.getGroupId() == group.getGroupId()) {
                    if (!curItem.isCheckable()) {
                        continue;
                    }

                    // Check the item meant to be checked,
                    // un-check the others (that are in the group)
                    if (curItem != item) {
                        curItem.setCheckedInt(false);
                    }
                }
            }
        }
    }

    protected List<SublimeBaseMenuItem> getItemsForGroup(int groupId) {
        ArrayList<SublimeBaseMenuItem> groupItems = new ArrayList<>();

        final int N = mItems.size();

        for (int i = 0; i < N; i++) {
            SublimeBaseMenuItem item = mItems.get(i);
            if (item.getGroupId() == groupId) {
                groupItems.add(item);
            }
        }

        return groupItems;
    }

    protected int getVisibleItemCountForGroup(List<SublimeBaseMenuItem> groupItems) {
        int visibleItems = 0;
        for (SublimeBaseMenuItem menuItem : groupItems) {
            if (menuItem.isVisible()) {
                visibleItems++;
            }
        }

        return visibleItems;
    }

    public boolean hasVisibleItems() {
        final int size = size();

        for (int i = 0; i < size; i++) {
            SublimeBaseMenuItem item = mItems.get(i);
            if (item.isVisible()) {
                return true;
            }
        }

        return false;
    }

    public boolean groupHasVisibleItems(int groupId) {
        final int size = size();

        for (int i = 0; i < size; i++) {
            SublimeBaseMenuItem item = mItems.get(i);
            if (item.getGroupId() == groupId && item.isVisible()) {
                return true;
            }
        }

        return false;
    }

    public SublimeBaseMenuItem getMenuItem(int itemId) {
        final int size = size();
        for (int i = 0; i < size; i++) {
            SublimeBaseMenuItem item = mItems.get(i);
            if (item.getItemId() == itemId) {
                return item;
            }
        }

        return null;
    }

    private int findItemIndex(int itemId) {
        final int size = size();

        for (int i = 0; i < size; i++) {
            SublimeBaseMenuItem item = mItems.get(i);
            if (item.getItemId() == itemId) {
                return i;
            }
        }

        return -1;
    }

    private int findGroupIndex(int groupId) {
        final int size = size();

        for (int i = 0; i < size; i++) {
            final SublimeBaseMenuItem item = mItems.get(i);
            if (item.getGroupId() == groupId) {
                return i;
            }
        }

        return -1;
    }

    /**
     * Returns the last index at which a member of the indicated group
     * exists. If the group currently does not have any members,
     * size of the MenuItem-list is returned.
     *
     * @param groupId ID of the group whose last member's index needs to be
     *                found
     * @return index of the last member of the indicated group, or size of
     * the MenuItem-list if no members are found.
     */
    private int findLastGroupIndex(int groupId) {
        int i = 0, size = mItems.size();
        boolean traversingGroup = false;
        while (true) {
            if (i < size) {
                final SublimeBaseMenuItem item = mItems.get(i);

                if (item.getGroupId() == groupId) {
                    traversingGroup = true;
                } else if (traversingGroup) {
                    // Take one step back
                    return i - 1;
                }

                i++;
            } else {
                return traversingGroup ? size - 1 : size;
            }
        }
    }

    public int size() {
        return mItems.size();
    }

    public Context getContext() {
        return mContext;
    }

    boolean dispatchMenuItemSelected(SublimeBaseMenuItem item,
                                     OnNavigationMenuEventListener.Event event) {
        return mCallback != null && mCallback.onMenuItemSelected(this, item, event);
    }

    public boolean performItemAction(SublimeBaseMenuItem item) {
        return !(item == null || !item.isEnabled()) && item.invoke();
    }

    public ArrayList<SublimeBaseMenuItem> getVisibleItems() {
        // Refresh the visible items
        mVisibleItems.clear();

        final int itemsSize = mItems.size();
        SublimeBaseMenuItem item;
        for (int i = 0; i < itemsSize; i++) {
            item = mItems.get(i);
            if (item.isVisible()) mVisibleItems.add(item);
        }

        return mVisibleItems;
    }

    //----------------------------------------------------------------//
    //---------------------------Item changes-------------------------//
    //----------------------------------------------------------------//

    protected SublimeMenu blockUpdates() {
        mBlockUpdates = true;
        return this;
    }

    protected SublimeMenu allowUpdates() {
        mBlockUpdates = false;
        return this;
    }

    public void finalizeUpdates() {
        if (mBlockUpdates) {
            Log.e(TAG, "Cannot finalize updates until 'allowUpdates()' is called.");
            return;
        }

        if (mPresenter == null) {
            Log.e(TAG, "Cannot finalize updates until a presenter is set.");
            return;
        }

        mPresenter.invalidateEntireMenu();
    }

    private void attemptUpdate() {
        if (!mBlockUpdates) {
            finalizeUpdates();
        }
    }

    //----------------------------------------------------------------//
    //---------------------------Adapter data-------------------------//
    //----------------------------------------------------------------//

    public static class Change {
        protected enum ChangeType {
            ITEM_INSERTED, ITEM_REMOVED,
            ITEM_CHANGED, ITEM_MOVED,
            RANGE_INSERTED, RANGE_REMOVED,
            RANGE_CHANGED, INVALIDATE_ENTIRE_MENU
        }

        // Used with ChangeType: ITEM_INSERTED, ITEM_REMOVED, ITEM_CHANGED,
        // RANGE_INSERTED, RANGE_REMOVED, RANGE_CHANGED
        private int mAffectedPosition;

        // Used with ChangeType: ITEM_MOVED
        private int mMovedFromPosition;
        private int mMovedToPosition;

        // Used with ChangeType: RANGE_INSERTED, RANGE_REMOVED, RANGE_CHANGED
        private int mNumberOfAffectedItems;

        private ChangeType mChangeType;

        public Change(ChangeType changeType, int affectedPosition, int movedFromPosition,
                      int movedToPosition, int numberOfAffectedItems) {
            mChangeType = changeType;
            mAffectedPosition = affectedPosition;
            mMovedFromPosition = movedFromPosition;
            mMovedToPosition = movedToPosition;
            mNumberOfAffectedItems = numberOfAffectedItems;
        }

        public ChangeType getChangeType() {
            return mChangeType;
        }

        public int getAffectedPosition() {
            return mAffectedPosition;
        }

        public int getNumberOfAffectedItems() {
            return mNumberOfAffectedItems;
        }

        public int getMovedFromPosition() {
            return mMovedFromPosition;
        }

        public int getMovedToPosition() {
            return mMovedToPosition;
        }
    }

    protected ArrayList<SublimeBaseMenuItem> getAdapterData() {
        // Possibly redundant check unless this method is
        // called from outside of SublimeMenuPresenterNew.
        // We shouldn't return 'null' here.
        if (mPresenter == null) return mAdapterData;

        prepareMenuItems();
        return mAdapterData;
    }

    /**
     * Creates/refreshes the data that is presented by SublimeMenuPresenter.
     */
    private void prepareMenuItems() {
        if (Config.DEBUG) {
            Log.i(TAG, "prepareMenuItems()");
        }

        mAdapterData.clear();

        boolean hasHeader = mPresenter != null && mPresenter.hasHeader();

        if (hasHeader) {
            mAdapterData.add(SublimeMenu.HEADER_STUB);
        }

        int i = 0;
        SublimeGroup currentGroup = null;

        for (int totalSize = getVisibleItems().size(); i < totalSize; ++i) {
            SublimeBaseMenuItem item = getVisibleItems().get(i);

            if (currentGroup == null || currentGroup.getGroupId() != item.getGroupId()) {
                currentGroup = getGroup(item.getGroupId());
            }

            if (currentGroup != null
                    && (!currentGroup.isVisible()
                    || (currentGroup.isCollapsed()
                    && item.getItemType() != SublimeBaseMenuItem.ItemType.GROUP_HEADER))) {
                continue;
            }

            mAdapterData.add(item);
        }
    }

    //----------------------------------------------------------------//
    //-----------------------Adapter data changes---------------------//
    //----------------------------------------------------------------//

    /**
     * Called when an item is changed. Type of change is evaluated
     * by comparing the 'old' position &amp; the 'new' position of the item.
     *
     * @param itemId id of item that's been changed
     */
    public void onItemChanged(int itemId) {
        if (mBlockUpdates || mPresenter == null) return;

        int oldPos = getAdapterPosForId(itemId);

        prepareMenuItems();

        int newPos = getAdapterPosForId(itemId);

        if (oldPos == -1 && newPos == -1) {
            // No change to report
            return;
        }

        if (oldPos == -1) {
            mPresenter.reportChange(
                    new Change(Change.ChangeType.ITEM_INSERTED, newPos, -1, -1, -1),
                    mAdapterData);
        } else if (newPos == -1) {
            mPresenter.reportChange(
                    new Change(Change.ChangeType.ITEM_REMOVED, oldPos, -1, -1, -1),
                    mAdapterData);
        } else if (oldPos == newPos) {
            mPresenter.reportChange(
                    new Change(Change.ChangeType.ITEM_CHANGED, newPos, -1, -1, -1),
                    mAdapterData);
        } else {
            mPresenter.reportChange(
                    new Change(Change.ChangeType.ITEM_MOVED, -1, oldPos, newPos, -1),
                    mAdapterData);
        }
    }

    /**
     * Called by {@link SublimeBaseMenuItem} after a batch update.
     */
    void onItemsChanged() {
        if (mBlockUpdates || mPresenter == null) return;

        mPresenter.invalidateEntireMenu();
    }

    private int getAdapterPosForId(int itemId) {
        for (int i = 0; i < mAdapterData.size(); i++) {
            if (mAdapterData.get(i).getItemId() == itemId) {
                return i;
            }
        }

        return -1;
    }

    //----------------------------------------------------------------//
    //--------------------------SublimeGroup--------------------------//
    //----------------------------------------------------------------//

    /**
     * Finds and returns the SublimeGroup with id == groupId.
     *
     * @param groupId id of the group to find
     * @return SublimeGroup with id == groupId if found, 'null' otherwise
     */
    public SublimeGroup getGroup(int groupId) {
        for (int i = 0; i < mGroups.size(); i++) {
            if (mGroups.get(i).getGroupId() == groupId) {
                return mGroups.get(i);
            }
        }

        return null;
    }

    /**
     * Called when a Group is collapsed/expanded.
     *
     * @param groupId   id of group that's been collapsed/expanded
     * @param collapsed 'true' if group has been collapsed, 'false' if expanded
     */
    protected void onGroupExpandedOrCollapsed(int groupId, boolean collapsed) {
        if (mBlockUpdates || mPresenter == null) return;

        List<SublimeBaseMenuItem> groupItems = getItemsForGroup(groupId);

        if (groupItems.size() > 0) {
            int headerPos = getAdapterPosForId(groupItems.get(0).getItemId());

            int visibleItemCountForGroupBeforeUpdate = getVisibleItemCountForGroup(groupItems);
            prepareMenuItems();
            int visibleItemCountForGroupAfterUpdate = getVisibleItemCountForGroup(groupItems);

            if (headerPos != -1) {
                // GroupHeader qualifies for ITEM_CHANGED.
                mPresenter.reportChange(
                        new Change(Change.ChangeType.ITEM_CHANGED, headerPos, -1, -1, -1),
                        mAdapterData);

                if (collapsed) {
                    // The '> 1' check determines if there are any
                    // GroupItems that are *visible*.
                    // '- 1' because the GroupHeader does not
                    // qualify for RANGE_REMOVED.
                    if (visibleItemCountForGroupBeforeUpdate > 1) {
                        mPresenter.reportChange(
                                new Change(Change.ChangeType.RANGE_REMOVED, headerPos + 1,
                                        //-1, -1, groupItems.size() - 1),
                                        -1, -1, visibleItemCountForGroupBeforeUpdate - 1),
                                mAdapterData);
                    }
                } else {
                    if (visibleItemCountForGroupAfterUpdate > 1) {
                        mPresenter.reportChange(
                                new Change(Change.ChangeType.RANGE_INSERTED, headerPos + 1,
                                        //-1, -1, groupItems.size() - 1),
                                        -1, -1, visibleItemCountForGroupAfterUpdate - 1),
                                mAdapterData);
                    }
                }
            } else {
                // be safe
                mPresenter.invalidateEntireMenu();
            }
        }
    }

    /**
     * Called when a Group's visibility is changed.
     *
     * @param groupId id of group that is now visible/invisible
     * @param visible 'true' if the group is now visible, 'false' otherwise
     */
    protected void onGroupVisibilityChanged(int groupId, boolean visible) {
        if (mBlockUpdates || mPresenter == null) return;

        List<SublimeBaseMenuItem> groupItems = getItemsForGroup(groupId);

        if (groupItems.size() > 0) {
            boolean invalidateEntireMenu = false;

            if (visible) {
                prepareMenuItems();
                int headerPos = getAdapterPosForId(groupItems.get(0).getItemId());
                if (headerPos != -1) {
                    mPresenter.reportChange(
                            new Change(Change.ChangeType.RANGE_INSERTED, headerPos,
                                    //-1, -1, groupItems.size()),
                                    -1, -1, getVisibleItemCountForGroup(groupItems)),
                            mAdapterData);
                } else {
                    // be safe
                    invalidateEntireMenu = true;
                }
            } else {
                // Get position & count before preparing updated menu
                int headerPos = getAdapterPosForId(groupItems.get(0).getItemId());
                int visibleItemCountForGroup = getVisibleItemCountForGroup(groupItems);
                prepareMenuItems();
                if (headerPos != -1) {
                    mPresenter.reportChange(
                            new Change(Change.ChangeType.RANGE_REMOVED, headerPos,
                                    //-1, -1, groupItems.size()),
                                    -1, -1, visibleItemCountForGroup),
                            mAdapterData);
                } else {
                    invalidateEntireMenu = true;
                }
            }

            if (invalidateEntireMenu) {
                // be safe
                mPresenter.invalidateEntireMenu();
            }
        }
    }

    /**
     * Called in response to change in 'collapsible' status of a group
     *
     * @param sublimeGroup group for which 'collapsible' status has changed
     */
    protected void onGroupCollapsibleStatusChanged(SublimeGroup sublimeGroup) {
        if (mBlockUpdates || mPresenter == null) return;

        List<SublimeBaseMenuItem> groupItems = getItemsForGroup(sublimeGroup.getGroupId());

        if (groupItems.size() > 0) {
            int headerPos = getAdapterPosForId(groupItems.get(0).getItemId());
            if (headerPos != -1) {
                if (sublimeGroup.isCollapsible() || !sublimeGroup.isCollapsed()) {
                    // Todo: check if call to 'prepareMenuItems()' is required
                    mPresenter.reportChange(
                            new Change(Change.ChangeType.ITEM_CHANGED, headerPos,
                                    -1, -1, -1),
                            mAdapterData);
                } else {
                    sublimeGroup.setStateCollapsed(false);
                }
            } else {
                // be safe
                mPresenter.invalidateEntireMenu();
            }
        }
    }

    /**
     * Called when a Group is enabled/disabled.
     *
     * @param groupId 'id' of group that's been enabled/disabled
     * @param enabled 'true' if the group has been 'enabled', false
     *                otherwise
     */
    protected void onGroupEnabledOrDisabled(int groupId, boolean enabled) {
        if (mBlockUpdates || mPresenter == null) return;

        List<SublimeBaseMenuItem> groupItems = getItemsForGroup(groupId);

        for (SublimeBaseMenuItem item : groupItems) {
            item.blockUpdates().setEnabled(enabled).allowUpdates();
        }

        if (groupItems.size() > 0) {
            int firstPos = getAdapterPosForId(groupItems.get(0).getItemId());
            if (firstPos != -1) {
                mPresenter.reportChange(
                        new Change(Change.ChangeType.RANGE_CHANGED, firstPos,
                                //-1, -1, groupItems.size()),
                                -1, -1, getVisibleItemCountForGroup(groupItems)),
                        mAdapterData);
            } else {
                // be safe
                mPresenter.invalidateEntireMenu();
            }
        }
    }

    /**
     * Sets the 'checkable' behavior for this group. For more information,
     * see {@link SublimeGroup#setCheckableBehavior(SublimeGroup.CheckableBehavior)}.
     *
     * @param groupId              'id' for which to set the new 'checkableBehavior'
     * @param newCheckableBehavior the 'checkableBehavior' to set
     */
    protected void onGroupCheckableBehaviorChanged(
            int groupId, SublimeGroup.CheckableBehavior newCheckableBehavior) {
        List<SublimeBaseMenuItem> groupItems = getItemsForGroup(groupId);

        // flag set when 'newCheckableBehavior' is 'SINGLE' & the first
        // checked item is found.
        boolean foundCheckedIfExclusive = false;

        for (SublimeBaseMenuItem item : groupItems) {
            switch (newCheckableBehavior) {
                case NONE:
                    item.setCheckable(false);
                    break;
                case ALL:
                    item.setCheckable(true);
                    break;
                case SINGLE:
                    if (foundCheckedIfExclusive && item.isCheckable()) {
                        item.setChecked(false);
                    } else {
                        // Can an item be !checkable & checked?
                        if (item.isCheckable() && item.isChecked()) {
                            foundCheckedIfExclusive = true;
                        }
                    }
                    break;
            }
        }
    }

    //----------------------------------------------------------------//
    //---------------------------Parcelable---------------------------//
    //----------------------------------------------------------------//

    public SublimeMenu(Parcel in) {
        readParcel(in);
    }

    private void readParcel(Parcel in) {
        mMenuResourceID = in.readInt();

        in.readTypedList(mItems, SublimeBaseMenuItem.CREATOR);

        for (SublimeBaseMenuItem item : mItems) {
            item.setParentMenu(this);
        }

        in.readTypedList(mGroups, SublimeGroup.CREATOR);

        for (SublimeGroup group : mGroups) {
            group.setParentMenu(this);
        }
    }

    @Override
    public int describeContents() {
        return 0;
    }

    @Override
    public void writeToParcel(Parcel dest, int flags) {
        dest.writeInt(mMenuResourceID);
        dest.writeTypedList(mItems);
        dest.writeTypedList(mGroups);
    }

    public static final Creator CREATOR = new Creator() {
        public SublimeMenu createFromParcel(Parcel in) {
            return new SublimeMenu(in);
        }

        public SublimeMenu[] newArray(int size) {
            return new SublimeMenu[size];
        }
    };
}
